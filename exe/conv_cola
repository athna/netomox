#!/usr/bin/env ruby

require 'json'
require 'netomox'
require 'optparse'

# cola network data
# data for CoLa gridifiedSmallGroups
# https://github.com/tgdwyer/WebCola/blob/master/WebCola/examples/gridifiedSmallGroups.html
# https://github.com/tgdwyer/WebCola/blob/master/WebCola/examples/graphdata/smallgrouped.json
class SmallGroupedNetwork
  attr_accessor :nodes, :links, :groups

  def initialize
    @nodes = []
    @links = []
    @groups = []
    @cola_node_index = 0
    @cola_node_index_of = {} # index dictionary of ColaNode
    @cola_group_index = 0
    @cola_group_index_of = {} # index dictionary of ColaGroup
  end

  def to_data
    {
      nodes: @nodes,
      links: @links,
      groups: @groups
    }
  end

  protected

  def make_cola_node(name)
    {
      name: name,
      index: @cola_node_index,
      width: 30,
      height: 20
    }
  end

  def append_cola_node(name)
    cola_node = make_cola_node(name)
    @nodes.push cola_node
    @cola_node_index_of[name] = cola_node[:index]
    @cola_node_index += 1
  end

  def make_cola_link(source, target)
    {
      source: @cola_node_index_of[source],
      target: @cola_node_index_of[target]
    }
  end

  def append_cola_link(source, target)
    cola_link = make_cola_link(source, target)
    @links.push cola_link
  end

  def append_cola_group_table(group_name, leaf)
    unless @cola_group_index_of[group_name]
      @cola_group_index_of[group_name] = {
        index: @cola_group_index,
        leaves: []
      }
      @cola_group_index += 1
    end
    @cola_group_index_of[group_name][:leaves].push(leaf)
  end

  def make_cola_group(index, leaves)
    {
      index: index,
      leaves: leaves
    }
  end
end

# Topology to CoLa data converter
# to visualize support-node-reference
class SupportNodeNetwork < SmallGroupedNetwork
  def initialize(nws)
    super()
    @nws = nws # original network data
    convert
  end

  private

  def convert
    set_cola_nodes_from_nodes
    set_cola_links_from_snodes
    set_cola_groups
  end

  # create cola-node data from nodes
  def set_cola_nodes_from_nodes
    @nws.all_nodes do |node, _nw|
      append_cola_node(node.path)
    end
  end

  # create cola-link data by supporting-node
  def set_cola_links_from_snodes
    @nws.all_nodes do |node, _nw|
      node.supports.each do |snode|
        append_cola_link(node.path, snode.ref_path)
      end
    end
  end

  def make_group_index_table
    @nodes.each do |cola_node|
      nw_path = cola_node[:name].split('/')[0]
      append_cola_group_table(nw_path, cola_node[:index])
    end
  end

  def set_cola_groups
    make_group_index_table
    @cola_group_index_of.each_pair do |_nw_path, group|
      group_data = make_cola_group(group[:index], group[:leaves])
      @groups.push group_data
    end
  end
end

# Topology to CoLa data converter
# to visualize node/tp hierarchy as nest
class LayerNestedNetwork < SmallGroupedNetwork
  def initialize(nws)
    super()
    @nws = nws # original network data
    convert
  end

  private

  def convert
    # nodes
    set_cola_nodes_from_tps
    # links
    set_cola_links_from_links
    set_cola_links_from_stps
    # groups
    set_cola_groups
  end

  # create cola-node data from term points
  def set_cola_nodes_from_tps
    @nws.all_termination_points do |tp, _node, _nw|
      append_cola_node(tp.path)
    end
  end

  # create cola-link data by link
  def set_cola_links_from_links
    @nws.all_links do |link, _nw|
      append_cola_link(link.source.ref_path, link.destination.ref_path)
    end
  end

  # create cola-link data by supporting-tp
  def set_cola_links_from_stps
    @nws.all_termination_points do |tp, _node, _nw|
      tp.supports.each do |stp|
        append_cola_link(tp.path, stp.ref_path)
      end
    end
  end

  # create cola groups (by each host, term points are leaves)
  def make_group_index_table
    @nodes.each do |cola_node|
      # cola_node means tp
      # node_path means node.path of parent of tp
      node_path = cola_node[:name].split('/').slice(0..1).join('/')
      append_cola_group_table(node_path, cola_node[:index])
    end
  end

  # create cola groups (by supporting node)
  def make_parent_node_table
    @parent_nodes_of = {}
    @nws.all_nodes do |node, _nw|
      node.supports.each do |snode|
        snode_path = snode.ref_path
        unless @parent_nodes_of[snode_path]
          @parent_nodes_of[snode_path] = []
        end
        @parent_nodes_of[snode_path].push node.path
      end
    end
  end

  # check reference count
  def find_multi_ref_nodes
    ref_count = {}
    @parent_nodes_of.each_value do |parents|
      parents.each do |parent_path|
        ref_count[parent_path] = 0 unless ref_count[parent_path]
        ref_count[parent_path] += 1
      end
    end
    ref_count.select {|_k,v| v > 1}.keys
  end

  # construct cola group data
  def set_cola_groups
    make_group_index_table
    make_parent_node_table
    multi_ref_nodes = find_multi_ref_nodes
    @cola_group_index_of.each_pair do |node_path, group|
      group_data = make_cola_group(group[:index], group[:leaves])
      unless @parent_nodes_of[node_path]
        @groups.push group_data
        next
      end
      parents = @parent_nodes_of[node_path] - multi_ref_nodes
      unless parents.empty?
        group_data[:groups] = parents.map do |parent_path|
          @cola_group_index_of[parent_path][:index]
        end
      end
      @groups.push group_data
    end
  end
end

# parse options
params = ARGV.getopts('12df:', 'file:')

# read topology data (json)
file = params['f'] || params['file']
unless file
  STDERR.puts 'file not specified'
  exit(1)
end
data = JSON.parse(File.read(file))
nws = Netomox::Topology::Networks.new(data)

# convert data (option:[12] specify a kind of converter)
cola_networks = if params['2']
                  SupportNodeNetwork.new(nws)
                else
                  # opt:1 (default)
                  LayerNestedNetwork.new(nws)
                end
puts JSON.pretty_generate(cola_networks.to_data)
